

<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-6DBZB44BXE"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-6DBZB44BXE');
    </script>
    <!-- General -->
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Model Formats in Systems Pharmacology. Part 1: The Missing Link Between Biology and Software Engineering</title>
    <meta name="description" content="QSP modeling still suffers from incompatible “black box” formats. This article explores why open, standardized formats are key to fixing it." />
    <meta name="author" content="Evgeny Metelkin" />
    <!-- article -->
    <meta property="article:author" content="https://metelkin.me" />
    <meta property="article:published_time" content="2025-08-22T00:00:00Z" />
    <meta property="article:modified_time" content="2025-08-22T00:00:00Z" />
    <!-- SEO -->
    <link rel="canonical" href="https://metelkin.me/model-formats-for-systems-pharmacology-1" />
    <!-- Open Graph -->
    <meta property="og:title" content="Model Formats in Systems Pharmacology. Part 1: The Missing Link Between Biology and Software Engineering" />
    <meta property="og:description" content="QSP modeling still suffers from incompatible “black box” formats. This article explores why open, standardized formats are key to fixing it." />
    <meta property="og:url" content="https://metelkin.me/model-formats-for-systems-pharmacology-1" />
    <meta property="og:image" content="https://metelkin.me/model-formats-for-systems-pharmacology-1/img/fig0-cover.jpg" />
    <meta property="og:site_name" content="Evgeny Metelkin" />
    <meta property="og:type" content="article" />
    <!-- Style -->
    <link rel="icon" href="/assets/favicon.ico" type="image/x-icon">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/water.css@2/out/water.min.css">
    <!--<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@5.8.1/github-markdown-light.min.css">-->
    <style>
        //.markdown-body { max-width: 70ch; margin-inline: auto; padding: 2rem; }
        .container { display: flex; gap: 10px; }
        .half { box-sizing: border-box; }
        .half:first-child { width: 60%;}
        .half:last-child { width: 40%; }

        @media (max-width: 768px) {
            .container { flex-direction: column; }
            .half { width: 100% !important; }
            .half:last-child img { width: 100%; height: auto; display: block; }
        }
    </style>
    <!-- To highlight code -->
	<link href="https://unpkg.com/prismjs@1.20.0/themes/prism-okaidia.css" rel="stylesheet"/>
    <!-- MathJax -->
    <script>
        window.MathJax = {
            tex: { 
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$','$$'], ['\\[','\\]']]
            },
            svg: { fontCache: 'global' }
        };
    </script>
    <script id="MathJax-script" async
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
    </script>
</head>

<body>
    
    <h1>Model Formats in Systems Pharmacology. Part 1</h1>
    <h2>The Missing Link Between Biology and Software Engineering</h2>
    <div>
        <p><strong>Evgeny Metelkin</strong></p>
        <p><strong>2025-08-22</strong></p>
    </div>
    <dev class="markdown-body">
        <p><img src="./img/fig0-cover.jpg" alt="Cover"></p>
<h2>1. Intro</h2>
<p>Imagine web development where every framework has its own version of HTML, CSS, and JavaScript.<br>
Git is almost useless: the project is a mix of binary files and settings hidden in a GUI.<br>
CI/CD can't be set up: the model doesn't always run from the command line.<br>
Code can't be reused: each tool has its own syntax, its own logic, and a closed &quot;project file&quot;.</p>
<p>Sounds like a bad alternate reality, but this is still how model storage and exchange often look in drug modeling. Tools solve similar problems, but model formats are incompatible; project structure is a &quot;black box&quot;; reproducibility is fragile; exchange is painful.</p>
<p>In this article, we propose looking at a pharmacological model as code, and at the model format as an interface between people and tools.</p>
<p>We'll explore:</p>
<ul>
<li>what QSP is and the role modeling plays in pharmacology;</li>
<li>what makes up a QSP model and how mathematics turns into structure;</li>
<li>the main approaches to model description (ODE scripts, process-based DSLs, tables, visual editors);</li>
<li>how popular tools store projects and where collaboration breaks down;</li>
<li>which software engineering practices (layered architecture, testing, CI/CD, semantic diffs) can actually work in QSP;</li>
<li>how we can improve the situation with model formats in QSP.</li>
</ul>
<h2>2. Why QSP Matters</h2>
<p>Today, computational biology and mathematical modeling are essential in drug development - from early preclinical experiments in a test tube to full-scale clinical trials in humans. Major pharmaceutical companies are investing heavily in this field, hiring top experts in computational biology to streamline the process and make it more effective (<a href="https://doi.org/10.1007/s10928-024-09905-y" target="_blank" rel="noopener noreferrer">Industry Perspective, JPKPD, 2024</a>; <a href="https://doi.org/10.1124/jpet.123.001842" target="_blank" rel="noopener noreferrer">Promotional Submission of QSP, JPET, 2024</a>).</p>
<p>One of the fastest-growing areas is Quantitative Systems Pharmacology (QSP). In short, QSP builds detailed mathematical models that describe how drugs interact with the human body and how biological systems respond in return (<a href="https://customsitesmedia.usc.edu/wp-content/uploads/sites/106/2012/12/17062522/NIH-White-Papaer-2011.pdf" target="_blank" rel="noopener noreferrer">NIH QSP White Paper, 2011</a>).</p>
<p>Think of the human body as a complex engineered system - full of components, feedback loops, and regulators. QSP turns this system into math: models that allow pharmacologists, engineers, and statisticians to test drug behavior virtually before moving to costly and risky experiments in the lab or clinic. These models help researchers:</p>
<ul>
<li>predict how a drug will behave under different dosing regimens,</li>
<li>optimize treatment strategies,</li>
<li>identify risks before they show up in patients, and</li>
<li>explain failures in trials by uncovering hidden mechanisms.</li>
</ul>
<p>In other words, QSP lets you &quot;run&quot; a drug inside a virtual patient - much like an aerospace engineer tests a new airplane in a simulator long before the first real flight.</p>
<h3>How QSP Relates to Other Modeling Fields</h3>
<p>QSP sits at the intersection of several established areas:</p>
<ul>
<li>Systems Biology (SB) - models networks of molecules and cells non-related to pharmacology.</li>
<li>Physiologically Based Pharmacokinetics (PBPK) - models how drugs move through organs and tissues.</li>
<li>Pharmacokinetics/Pharmacodynamics (PK/PD) - links drug concentration to its therapeutic effect, typically empirically.</li>
</ul>
<p>QSP combines elements of all three, but adds a unique focus on bridging molecular mechanisms with whole-body pharmacology and clinical outcomes.</p>
<h3>Why Software Engineers Should Care</h3>
<p>From a developer's perspective, QSP projects look surprisingly familiar:</p>
<ul>
<li>there is code (equations, parameters, model structure),</li>
<li>there are tests (validation against clinical or experimental data),</li>
<li>there are versions (models evolve as new data arrives),</li>
<li>there are teams working together on the same project,</li>
<li>and there are real concerns about readability, reproducibility, and maintainability.</li>
</ul>
<p>Drug modeling is starting to resemble software engineering but without the benefit of decades of best practices. That's why ideas like modularity, version control, open formats, and CI/CD are so relevant here.</p>
<h3>Current Challenges</h3>
<p>Despite its potential, QSP as a field still struggles with systemic problems:</p>
<ul>
<li>difficulty working in teams and sharing models,</li>
<li>results that are hard to interpret outside specialized circles,</li>
<li>poor reproducibility across tools and groups,</li>
<li>lack of standardization in formats and workflows,</li>
<li>and the burden of updating or extending models as new data becomes available.</li>
</ul>
<h2>3. Anatomy of QSP models</h2>
<h3>Core Concepts</h3>
<p>In Quantitative Systems Pharmacology (QSP), the human body is typically represented as a network of biochemical reactions and interactions operating across multiple scales - from organs to cells to molecules. Regardless of the level of detail, these systems can usually be described in a common set of core concepts:</p>
<ul>
<li>States – Concentrations of molecules, numbers of cells, organ volumes and dimensions, clinical biomarkers.</li>
<li>Processes – Reactions, transport mechanisms, discrete events.</li>
<li>Parameters – Organ sizes and flows, molecular properties, interaction constants, masses.</li>
<li>Equations – Rate laws and transport equations, derived either from mechanistic descriptions or empirical relationships.</li>
<li>Datasets – Experimental, clinical, or literature data used for model calibration, validation, and testing.</li>
<li>Tasks – Practical goals for modeling such as dose optimization, treatment prediction, or, internally, parameter estimation, structural identification, verification, and uncertainty analysis.</li>
</ul>
<p>In most cases, the dynamics of such a system are expressed as a set of ordinary differential equations (ODEs). Given the complexity of biological systems, these models can become extremely high-dimensional. This alone makes the construction, updating, and maintenance of the equations a significant challenge. The exact topology of the system is rarely fixed - it evolves as the project progresses - which means that building such models requires dedicated workflows involving iterative refinement, validation, and testing.</p>
<p>If we borrow concepts from software engineering, we can draw parallels between a QSP model and application architecture.</p>
<ul>
<li>Model States are akin to domain states or stored fields.</li>
<li>Processes map to business logic.</li>
<li>Equations resemble specific algorithms.</li>
<li>Parameters function like configuration settings.</li>
<li>The ODE solver plays the role of a runtime or execution engine, &quot;running&quot; the model.</li>
<li>Tasks are comparable to use cases or automated test scenarios.</li>
</ul>
<p>The analogy isn't always perfect, but it highlights a useful perspective: there may be untapped opportunities to improve how we develop and maintain QSP models by borrowing proven practices from software engineering</p>
<h3>A Simple Example</h3>
<p>To make this more concrete, let's look at a highly simplified example - far smaller than what modelers deal with in practice, but enough to illustrate the key principles. For simplicity, we omit more advanced features such as dynamic volumes, flows, delays, complex branching reactions, and conditional events.</p>
<p>Imagine a minimal model of alcohol metabolism in the human body.<br>
<img src="./img/fig1-scheme.png" alt="Alcohol metabolism model"></p>
<p><strong>Fig 1. A toy QSP model of alcohol metabolism.</strong> This minimal example is used to illustrate model structure; real QSP models can include thousands of components and interactions.</p>
<p>In this example, ethanol is consumed twice (state Alc_g), absorbed into the bloodstream (Alc_b), metabolized into acetaldehyde (AcHc), and then further converted into acetate (Acet).</p>
<p>In ODE form, the model's core dynamics are:<br>
$$<br>
\begin{align}<br>
\frac{d(Alc_g)}{dt} &amp; = -vabs_{Alc},\\<br>
\frac{d(Alc_b \cdot blood)}{dt} &amp; = vabs_{Alc} - v_{ADH},\\<br>
\frac{d(AcHc \cdot blood)}{dt} &amp; = v_{ADH} - v_{ALDH},\\<br>
\frac{d(Acet \cdot blood)}{dt} &amp; = v_{ALDH}.<br>
\end{align}<br>
$$</p>
<p>The system also includes rate laws, parameter values, initial conditions, and discrete dosing events:</p>
<p>Rate laws (rules expressing concentration income/outcome):</p>
<p>$$<br>
\begin{aligned}<br>
vabs_{Alc} &amp; = kabs_{Alc} \cdot Alc_g,\\<br>
v_{ADH} &amp; =  \frac{Vmax_{ADH} \cdot Alc_b}{Km_{ADH} + Alc_b} \cdot blood,\\<br>
v_{ALDH} &amp; = \frac{Vmax_{ALDH} \cdot AcHc}{Km_{ALDH} + AcHc} \cdot blood.<br>
\end{aligned}<br>
$$</p>
<p>Parameter values (constants defining the fixed properties of the system):</p>
<p>$$<br>
\begin{aligned}<br>
&amp; gut = 1, blood = 5, \\<br>
&amp; kabs_{Alc} = 0.1, \\<br>
&amp; Vmax_{ADH} = 0.5, Km_{ADH} = 0.1, \\<br>
&amp; Vmax_{ALDH} = 0.5, Km_{ALDH} = 0.1.<br>
\end{aligned}<br>
$$</p>
<p>Initial conditions (initial amounts/concentrations at time zero)</p>
<p>$$<br>
\begin{aligned}<br>
&amp; Alc_g\left(0\right) = 0, \\<br>
&amp; Alc_b\left(0\right) = 0, \\<br>
&amp; AcHc\left(0\right) = 0, \\<br>
&amp; Acet\left(0\right) = 0.<br>
\end{aligned}<br>
$$</p>
<p>Dosing events (discrete inputs to the system at specific times):</p>
<p>$$<br>
\begin{aligned}<br>
Alc_g\left(2\right) &amp;\leftarrow Alc_g\left(2\right) +0.2,\\<br>
Alc_g\left(4\right) &amp;\leftarrow Alc_g\left(4\right) +0.2.<br>
\end{aligned}<br>
$$</p>
<p><img src="./img/fig2-dynamics.png" alt="Alcohol metabolism simulation results"></p>
<p><strong>Fig 2. Demo run of the toy alcohol model.</strong> Results are illustrative and qualitative, not quantitative. Definitely not medical advice (or bartending advice).</p>
<h3>Beyond the Core Equations</h3>
<p>In real-world projects, the mathematical core is important but just the part of the model.<br>
A complete, reproducible modeling package also needs:</p>
<ol>
<li>Structured annotations - explanations, limitations, and assumptions of model parts.</li>
<li>Input parameter sets describing specific conditions, doses, or patient characteristics.</li>
<li>Solver settings - the numerical methods and parameters used for ODE integration.</li>
<li>Datasets for calibration, validation, and testing.</li>
<li>Protocols for complex simulation workflows such as confidence interval estimation, sensitivity analysis, or uncertainty quantification.</li>
<li>Metadata - version history, authorship, run logs, and so on.</li>
</ol>
<p>Without these, results are not reproducible, and the model cannot be properly evaluated or reused.</p>
<p>Most modeling environments describe the model core in some form of equations and parameters, though with varying constraints.<br>
Some tools employ macro languages, domain-specific languages (DSLs), or graphical editors to simplify model creation.<br>
However - and this is the critical point - the underlying structures and storage formats vary widely between tools,<br>
there is no common standard, and auxiliary information is not always saved or cleanly separated from the model code.</p>
<p>In the next section, we'll see how the same model can look dramatically different across popular QSP tools<br>
and why that matters for both modelers and developers.</p>
<h2>4. Popular Tools and How They Store Models</h2>
<h3>Interaction Modes: How Users Author Models</h3>
<p>A mathematical model built on algebraic–differential equations is straightforward for mathematicians and modelers.<br>
But working with it directly? Not so much.</p>
<p><img src="./img/fig3-raw-matlab.png" alt="Raw scripting Matlab code"></p>
<p><strong>Fig 3. Example of raw scripting in Matlab.</strong> Model logic (right) and simulation script (left) live in separate files but are still entangled. The model carries redundant syntax just to satisfy MATLAB and cannot be directly reused in another language or tool. Adding a new reaction requires multiple updates in the model code and possibly in the simulation script.</p>
<p>For a computer program to use it, the model needs a structured markup language and parsers to read it.<br>
For biologists or pharmacologists-who may also be involved-it's even harder to interpret raw equations.</p>
<p>There's another practical challenge:<br>
ODE-based notation works fine for solvers, but if you introduce a complex reaction involving multiple metabolites, you often have to update several right-hand sides or add multiple new equations. This quickly becomes messy and error-prone.</p>
<p><img src="./img/fig4-mrgsolve.png" alt="ODE based DSL, mrgsolve"></p>
<p><strong>Fig 4. Example of ODE based DSL in mrgsolve.</strong> The model is expressed as a macro-like C++ dialect, which makes it close to the solver and mathematically transparent. However, large models become hard to maintain: even small structural changes may require rewriting the system of equations. The syntax is tool-specific and difficult to parse or convert, limiting portability beyond mrgsolve (and partially NONMEM).</p>
<p>One way around this is the <strong>process-based approach</strong>-describing the model in terms of processes that involve metabolites and other entities. The software then generates the ODE system automatically (e.g., from tables or a custom DSL) right before simulation. This approach reduces manual edits, enables modularity, and lowers the risk of mistakes.<br>
The trade-off? You need to adjust your modeling mindset. The equation-level view is hidden behind generation, and you need an explicit build pipeline. Still, this method has been influential-<a href="https://sbml.org/" target="_blank" rel="noopener noreferrer">SBML</a> is one example born from such thinking.</p>
<p>To make models even more approachable, some tools offer <strong>visual modeling</strong>-showing the model as a map or process graph. Great for accessibility, less so for large-scale version control.</p>
<p>In practice, different tools offer different interaction styles. For small models, it doesn't matter much which you choose. As complexity grows, the differences become critical-impacting usability, versioning, and collaboration. For example, comparing two versions, reusing components, or organizing a modular model is often much easier in a process-based DSL than in raw ODE code.</p>
<p>Broadly, user–model interaction falls into these categories:</p>
<ul>
<li><strong>Raw scripting</strong> - Pure code in a general-purpose language (MATLAB, Julia, R, Python). Maximum flexibility, minimal standardization. Equations are coded directly; solvers may also be custom-built.</li>
<li><strong>Visual modeling</strong> - The user draws diagrams, with equations and parameters hidden in annotations (e.g., SimBiology). Great for visualization, poor for Git diffs and mass editing.</li>
<li><strong>DSL-based modeling</strong> - A dedicated intermediate language. Balances readability, structure, and flexibility (e.g., HetaSimulator).</li>
<li><strong>Table-based modeling</strong> - The model is defined via spreadsheets or tabular formats. Readable, but limited in expressing complex logic.</li>
<li><strong>Mixed modeling</strong> - Combinations such as tables + DSL, or tables + diagrams.</li>
</ul>
<p><img src="./img/fig5-simbio.png" alt="Visual modeling SimBiology code snippet"></p>
<p><strong>Fig 5. Example of visual modeling in SimBiology.</strong> Visual diagrams make it easier for beginners and biologists to start modeling, but serious work still requires editing mathematical details hidden in tables and formulas. The binary storage format complicates version control and collaboration, while large models quickly become unwieldy as diagrams grow too complex to manage effectively.</p>
<h3>What Ends Up on Disk: Project Storage Formats</h3>
<p>Beyond authoring style, storage format matters-especially for collaboration, exchange, and version control.<br>
Some platforms store everything in a single file; others use multiple files in different formats.<br>
In QSP, these formats are usually incompatible.</p>
<p>Broad storage format categories:</p>
<ul>
<li><strong>Binary formats</strong> - Not human-readable, hard to diff.</li>
<li><strong>Proprietary text formats</strong> - Can be opened in a text editor, but structure is obscure and not meant for manual editing.</li>
<li><strong>Structured formats</strong> - Based on open standards (XML, SBML, JSON, YAML). Easier to parse and transform.</li>
<li><strong>Human-readable text</strong> - Best for Git and team workflows, but still needs a parser.</li>
</ul>
<p>A major step forward for modeling communities was <strong>SBML</strong> (<a href="https://doi.org/10.1515/jib-2017-0081" target="_blank" rel="noopener noreferrer">SBML Level 3 spec, 2018</a>), which standardized machine-readable model exchange.<br>
It enabled smoother tool integration and collaboration-but it's still an exchange format, not a project-editing format.<br>
It also doesn't address QSP-specific needs.</p>
<p>Other domain formats exist SED-ML for simulation tasks (<a href="https://doi.org/10.1186/1752-0509-5-198" target="_blank" rel="noopener noreferrer">SED-ML spec, BMC Systems Biology, 2011</a>),<br>
COMBINE archives for project packaging (<a href="https://doi.org/10.1186/s12859-014-0369-z" target="_blank" rel="noopener noreferrer">COMBINE spec, BMC Bioinformatics, 2014</a>),<br>
PETAB for experiment parameterization (<a href="https://doi.org/10.1371/journal.pcbi.1008646" target="_blank" rel="noopener noreferrer">PEtab spec, PLoS Comput Biol, 2021</a>) but they see limited adoption for QSP.</p>
<p><img src="./img/fig6-heta.png" alt="HetaSimulator code snippet"></p>
<p><strong>Fig 6. Example for process-based DSL. Code for HetaSimulator.</strong> Heta offers a solver- and scripting-independent way to describe models and works well with version control. Support modules and namespaces. However, the format is niche, less familiar to those used to ODEs, and may feel harder to adopt outside its community. Requires a specific <a href="https://hetalang.github.io/hetacompiler" target="_blank" rel="noopener noreferrer">translator</a> for use across applications.</p>
<h3>Tool Matrix: Authoring, Storage, and Interfaces</h3>
<p>QSP has been evolving since around 2010. Many of its tools are adapted from related fields:<br>
Systems Biology (SB), Physiologically Based Pharmacokinetics (PBPK), and Pharmacokinetics/Pharmacodynamics (PK/PD).<br>
Some were retooled for QSP; others are brand new.</p>
<p>Criteria for inclusion here:</p>
<ul>
<li>Mentioned in QSP software reviews (<a href="https://doi.org/10.1002/psp4.12373" target="_blank" rel="noopener noreferrer">QSP tools review, CPT-PSP, 2018</a>)</li>
<li>Positioned as QSP tools in docs or case studies</li>
<li>Designed for solving dynamics, not just auxiliary tasks</li>
</ul>
<table>
<thead>
<tr>
<th>Software</th>
<th>Interaction mode</th>
<th>Approach</th>
<th>Model/project file format</th>
<th>Interface</th>
<th>Initial scope</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://www.mathworks.com/help/simbio/index.html" target="_blank" rel="noopener noreferrer">SimBiology</a></td>
<td>Visual, Tables</td>
<td>Process-based</td>
<td>Binary (.sbproj)</td>
<td>GUI, Scripting (Matlab)</td>
<td>SB, QSP</td>
</tr>
<tr>
<td>Raw MATLAB</td>
<td>Raw scripting</td>
<td>ODE-based</td>
<td>Human-readable (.m)</td>
<td>Scripting (Matlab)</td>
<td>General purpose</td>
</tr>
<tr>
<td><a href="https://hetalang.github.io" target="_blank" rel="noopener noreferrer">HetaSimulator</a></td>
<td>DSL, Tables</td>
<td>Process-based</td>
<td>Human-readable (.heta)</td>
<td>Scripting (Julia)</td>
<td>QSP</td>
</tr>
<tr>
<td><a href="https://docs.pumas.ai/stable/" target="_blank" rel="noopener noreferrer">Pumas</a></td>
<td>DSL</td>
<td>ODE-based</td>
<td>Human-readable (.jl)</td>
<td>Scripting (Julia)</td>
<td>PK/PD, QSP</td>
</tr>
<tr>
<td><a href="https://www.open-systems-pharmacology.org/" target="_blank" rel="noopener noreferrer">PK-Sim/MoBi</a></td>
<td>Tables, Visual</td>
<td>ODE-based</td>
<td>Structured (.xml, .pkml)</td>
<td>Scripting (R)</td>
<td>PBPK</td>
</tr>
<tr>
<td><a href="https://iqrtools.intiquan.com/" target="_blank" rel="noopener noreferrer">IQR Tools</a></td>
<td>DSL</td>
<td>ODE-based</td>
<td>Human readable (.txt)</td>
<td>Scripting (R)</td>
<td>PK/PD</td>
</tr>
<tr>
<td><a href="https://mrgsolve.org/" target="_blank" rel="noopener noreferrer">mrgsolve</a></td>
<td>DSL</td>
<td>ODE-based</td>
<td>Human-readable (.mod)</td>
<td>Scripting (R)</td>
<td>PK/PD</td>
</tr>
<tr>
<td><a href="https://sourceforge.net/projects/dbsolve/" target="_blank" rel="noopener noreferrer">DBSolve</a></td>
<td>Mixed: DSL + Tables</td>
<td>ODE-based</td>
<td>Proprietary text (.slv)</td>
<td>GUI</td>
<td>SB</td>
</tr>
<tr>
<td><a href="https://www.berkeleymadonna.com/" target="_blank" rel="noopener noreferrer">Berkeley Madonna</a></td>
<td>Mixed: DSL + Tables</td>
<td>ODE-based, Process-based</td>
<td>Proprietary text (.mmd)</td>
<td>GUI</td>
<td>General purpose</td>
</tr>
<tr>
<td><a href="https://www.certara.com/software/simcyp-pbpk/" target="_blank" rel="noopener noreferrer">SimCYP</a></td>
<td>Tables</td>
<td>ODE-based (*restricted)</td>
<td>Proprietary text (.wksz)</td>
<td>GUI, Scripting (R)</td>
<td>PBPK</td>
</tr>
<tr>
<td><a href="https://www.simulations-plus.com/software/gastroplus/" target="_blank" rel="noopener noreferrer">GastroPlus</a></td>
<td>Tables</td>
<td>ODE-based (*restricted)</td>
<td>Binary (.gpj)</td>
<td>GUI</td>
<td>PBPK</td>
</tr>
<tr>
<td><a href="https://monolixsuite.slp-software.com/monolix/2024R1/" target="_blank" rel="noopener noreferrer">Monolix</a></td>
<td>Mixed: DSL, Tables</td>
<td>ODE-based</td>
<td>Human-readable (.mlxtran, .txt)</td>
<td>GUI, Scripting (R, Python)</td>
<td>PK/PD</td>
</tr>
<tr>
<td><a href="https://www.iconplc.com/solutions/technologies/nonmem" target="_blank" rel="noopener noreferrer">NONMEM</a></td>
<td>Mixed: DSL, Tables</td>
<td>ODE-based</td>
<td>Human-readable (.ctl, .mod)</td>
<td>CLI, Scripting (PsN/Pirana)</td>
<td>PK/PD</td>
</tr>
<tr>
<td><a href="https://jdesigner.sourceforge.net/Site/JDesigner.html" target="_blank" rel="noopener noreferrer">JDesigner</a></td>
<td>Visual</td>
<td>Process-based</td>
<td>Binary (.jdes)</td>
<td>GUI</td>
<td>SB</td>
</tr>
<tr>
<td>PhysioLab by Enthelos</td>
<td>DSL</td>
<td>ODE-based</td>
<td>Proprietary text(.phl)</td>
<td>GUI</td>
<td>QSP</td>
</tr>
</tbody>
</table>
<p><em>* restricted - limited access to the ODE structure; pre-generated for drug distribution models.</em></p>
<p>Although these tools solve similar problems, their formats are rarely compatible.<br>
Switching often means rewriting models from scratch or doing painful manual conversions.<br>
Most tools store states, equations, parameters, data, and tasks all together-making modular reuse and Git-based workflows difficult.<br>
In DevOps terms, this is a serious bottleneck for CI/CD in model development.</p>
<hr>
<p>This was a look at the problems around how QSP models are stored and shared. Next time, We'll reflect on possible ways forward - treating models as code, open formats, and what we might learn from software engineering.</p>
<p><strong>To be continued…</strong></p>

    </dev>
    <dev>
        <p><strong>License: <a href="https://creativecommons.org/licenses/by/4.0/" target="_blanc">CC-BY-4.0</a></strong></p> 
    </dev>

</body>
